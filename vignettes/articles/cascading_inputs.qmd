---
title: "Cascading inputs"
filters:
  - shinylive
---

In Shiny applications, it's common to have inputs that depend on one another. For example, a user might first select a state, and a second dropdown is then populated with cities from that state. This is often called "cascading inputs".

While this is a powerful feature, it can introduce subtle bugs related to timing. When the first input changes, there is a brief moment where the second input still holds its old value, which may now be invalid. If a downstream reactive calculation depends on both inputs, it can briefly receive an inconsistent state, potentially leading to errors or triggering slow, unnecessary computations.

## The Problem

Consider the following application. It has two `selectInput` controls: "Level" and "Group". The available choices for "Group" depend on the selected "Level". When you change the "Level", the "Group" input becomes temporarily invalid before it is updated with new choices.

In this example, we've added a `Sys.sleep(5)` to simulate a long-running operation that gets triggered when the app receives an inconsistent state. Try changing the "Level" from "A" to "B". You will see a modal dialog appear for 5 seconds, demonstrating the problem.

```{shinylive-r}
#| label: motivating-example
#| standalone: true
#| viewerHeight: 300
#| components: [editor, viewer]
#| layout: vertical
{{< include ../../inst/apps/cascading_filters/shiny/app.R >}}
```

## The Solution: `vrv_factor()`

The `chains` package provides `vrv_factor()` (and a single-value version, `vrv_factor_scalar()`) to solve this problem. `vrv_factor()` is a specialized wrapper around the more general `validated_reactive_val()` to ensure that the value is always factor-like, validating to a specific set of allowed values. You provide it an (optionally reactive) expression for the valid `levels`, and `vrv_factor()` guarantees that its values are always in those levels. If its current set of values becomes invalid (either because the `levels` change or you attempt to set an invalid value), it returns a default value (which can also be calculated via a reactive expression) instead.

By guaranteeing a valid state, `vrv_factor()` prevents downstream reactives from ever observing an inconsistent set of inputs. When the `vrv_factor()`'s value is invalid, it returns its default (`NULL` if not otherwise specified). A downstream reactive using `shiny::req()` will then correctly halt execution, preventing errors or unnecessary calculations until a consistent state is restored.

In the updated app below, we use `chains::vrv_factor_scalar()` to manage the state of the "Group" input. Notice how this simplifies the server function significantly. When you invalidate the "Group" by changing the "Level", the downstream calculation never sees the inconsistent state, so the error modal no longer appears. The application remains responsive and proceeds with the consistent inputs.

```{shinylive-r}
#| label: solution-example
#| standalone: true
#| viewerHeight: 300
#| components: [editor, viewer]
#| layout: vertical
webr::install("chains", repos = c("https://chains.shinyworks.org/", "https://shinyworks.r-universe.dev/", "https://stbl.api2r.org", "https://api2r.r-universe.dev", "https://repo.r-wasm.org/"))
{{< include ../../inst/apps/cascading_filters/chains/app.R >}}
```
